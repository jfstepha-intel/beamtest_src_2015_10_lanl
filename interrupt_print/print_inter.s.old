
.org 0x0000000000200000
   .text
   .global main
main:
    nop

call_test:
    nop
    nop
    call subrout
    nop
    nop
    jmp call_test

subrout:
    nop
    ret

int_handle_return:
    cli
    sti
    iretq
    iret

/* The individual interrupt handlers just push */
/* an ascii version of the interupt number onto the */
/* stack, then call the main interrupt handler */

.macro interrupt_print p
   nop

int_handle_\p:
    nop
    cli
    xor %eax, %eax

    /* Print the interrupt message */
    movl $msg_int_\p, %ecx
    
ser_poll_i_\p:

    mov $0x3fd, %edx
    in %dx, %al
    test $0x20, %al
    jz ser_poll_i_\p
    mov (%ecx), %al
    mov $0x3f8, %edx
    out %al, %dx
    inc %ecx
    mov (%ecx), %al
    test %al, %al
    jnz ser_poll_i_\p
.endm

.macro interrupt_loop p

    /* Never return from the interrupt */
loop_i_\p:
    jmp loop_i_\p
.endm

.macro interrupt_ret p
    /* return from the interrupt routine */
    push %rcx
    xor %rcx, %rcx
    add $70000000, %rcx
 loop_delay_int_\p:
    nop
    loop loop_delay_int_\p
    pop %rcx

    sti
    iretd

.endm

/* the default interrupt just prints and returns */
.macro interrupt p
   interrupt_print \p
   interrupt_ret \p
.endm



   /****************************/
   /* The main interrupt table */
   /****************************/
    interrupt 0
    interrupt 1
    interrupt 2
    interrupt 3
    interrupt 4
    interrupt 5
    interrupt 6
    interrupt 7
    interrupt 8
    interrupt 9
    interrupt 10
    interrupt 11
    interrupt 12
    interrupt 13
    interrupt 14
    interrupt 15
    interrupt 16
    interrupt 17
    interrupt 18
    interrupt 19
    interrupt 32


force_int_32:
    nop
    sti 
    nop
    movl $msg_int_pre, %ecx

ser_poll_3:
    mov $0x3fd, %edx
    in %dx, %al
    test $0x20, %al
    jz ser_poll_3
    mov (%ecx), %al
    mov $0x3f8, %edx
    out %al, %dx
    inc %ecx
    mov (%ecx), %al
    test %al, %al
    jnz ser_poll_3


    nop
    int $32
    nop

    movl $msg_int_post, %ecx
ser_poll_4:
    mov $0x3fd, %edx
    in %dx, %al
    test $0x20, %al
    jz ser_poll_4
    mov (%ecx), %al
    mov $0x3f8, %edx
    out %al, %dx
    inc %ecx
    mov (%ecx), %al
    test %al, %al
    jnz ser_poll_4

    nop
int_done:
    nop
    jmp int_done

force_int_18:
    nop
    sti 
    nop
    movl $msg_int_pre, %ecx

ser_poll_3a:
    mov $0x3fd, %edx
    in %dx, %al
    test $0x20, %al
    jz ser_poll_3a
    mov (%ecx), %al
    mov $0x3f8, %edx
    out %al, %dx
    inc %ecx
    mov (%ecx), %al
    test %al, %al
    jnz ser_poll_3a


    nop
    int $18
    nop

    movl $msg_int_post, %ecx
ser_poll_4a:
    mov $0x3fd, %edx
    in %dx, %al
    test $0x20, %al
    jz ser_poll_4a
    mov (%ecx), %al
    mov $0x3f8, %edx
    out %al, %dx
    inc %ecx
    mov (%ecx), %al
    test %al, %al
    jnz ser_poll_4a

    nop
int_done_a:
    nop
    jmp int_done_a

send_ipi_to_0:

   mov $0xfee00310, %edx
   movl $0x00000000, (%edx)
   mov $0xfee00300, %edx
##  movl $0x00004020, (%edx)
   movl $0x00000020, (%edx)
ipi0_loop:
   jmp ipi0_loop

send_ipi_to_1:
   mov $0xfee00310, %edx
   movl $0x10000000, (%edx)
   mov $0xfee00300, %edx
##   movl $0x00004020, (%edx)
   movl $0x00000020, (%edx)
ipi1_loop:
   jmp ipi1_loop
   
    

msg_start:
    .ascii "Starting\r\n\0"
msg_int_0: .ascii "\xfe Interrupt 0: #DE Divide Error\r\n\0"
msg_int_1: .ascii "\xfe Interrupt 1: #DB Reserved\r\n\0"
msg_int_2: .ascii "\xfe Interrupt 2:     NMI Interrupt\r\n\0"
msg_int_3: .ascii "\xfe Interrupt 3: #BP Breakpoint\r\n\0"
msg_int_4: .ascii "\xfe Interrupt 4: #OF Overflow\r\n\0"
msg_int_5: .ascii "\xfe Interrupt 5: #BR BOUND Range Exceeded\r\n\0"
msg_int_6: .ascii "\xfe Interrupt 6: #UD Invalid Opcode\r\n\0"
msg_int_7: .ascii "\xfe Interrupt 7: #NM Device not Available (No Math Coprocessor)\r\n\0"
msg_int_8: .ascii "\xfe Interrupt 8: #DF Double Fault\r\n\0"
msg_int_9: .ascii "\xfe Interrupt 9:     Coprocessor Segment Overrun (reserved)\r\n\0"
msg_int_10: .ascii "\xfe Interrupt 10: #TS Invalid TSS\r\n\0"
msg_int_11: .ascii "\xfe Interrupt 11: #NP Segment Not Present\r\n\0"
msg_int_12: .ascii "\xfe Interrupt 12: #SS Stack-Segment Fault\r\n\0"
msg_int_13: .ascii "\xfe Interrupt 13: #GP General Protection\r\n\0"
msg_int_14: .ascii "\xfe Interrupt 14: #PF Page Fault\r\n\0"
msg_int_15: .ascii "\xfe Interrupt 15:     Reserved\r\n\0"
msg_int_16: .ascii "\xfe Interrupt 16: #MF x87 Floating-point Error (Math Fault)\r\n\0"
msg_int_17: .ascii "\xfe Interrupt 17: #AC Alignment Check\r\n\0"
msg_int_18: .ascii "\xfe Interrupt 18: #MC Machine Check\r\n\0"
msg_int_19: .ascii "\xfe Interrupt 19: #XM SIMD Floating-Point Exception\r\n\0"
msg_int_32: .ascii "\xfe Interrupt 32:     User defined\r\n\0"
msg_error:
    .ascii "\xfe Error.\r\n\0"
msg_int_pre:
    .ascii "\xfe Asserting interrrupt\r\n\0"
msg_int_post:
    .ascii "\xfe After int\r\n\0"

